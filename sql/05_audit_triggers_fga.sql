AUDIT SELECT, INSERT, UPDATE, DELETE ON gym_members BY ACCESS;

AUDIT INSERT, UPDATE, DELETE ON gym_contracts
  WHENEVER NOT SUCCESSFUL;

CREATE TABLE gym_audit_contracts (
    audit_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username      VARCHAR2(30),
    action        VARCHAR2(20),
    contract_id   NUMBER,
    old_status    VARCHAR2(20),
    event_date    DATE,
    rows_affected NUMBER,
    old_price     NUMBER(8,2),
    new_price     NUMBER(8,2)
);

CREATE OR REPLACE TRIGGER trg_gym_contracts_del
AFTER DELETE ON gym_contracts
FOR EACH ROW
BEGIN
    INSERT INTO gym_audit_contracts(
        username, action, contract_id, old_status, event_date, rows_affected
    )
    VALUES (
        USER, 'DELETE', :OLD.contract_id, :OLD.status, SYSDATE, 1
    );
END;

CREATE OR REPLACE TRIGGER trg_gym_subscriptions_price
AFTER UPDATE OF price ON gym_subscriptions
FOR EACH ROW
WHEN (NEW.price > 500)
BEGIN
    INSERT INTO gym_audit_contracts(
        username, action, contract_id,
        old_status, event_date,
        old_price, new_price, rows_affected
    )
    VALUES (
        USER,
        'UPDATE_PRICE',
        NULL,
        'SUBSCRIPTION_ID=' || :NEW.sub_id,
        SYSDATE,
        :OLD.price,
        :NEW.price,
        1
    );
END;

BEGIN
  dbms_fga.add_policy(
    object_schema    => USER,
    object_name      => 'GYM_CLASSES',
    policy_name      => 'FGA_ADVANCED_CLASSES',
    audit_condition  => 'difficulty = ''ADVANCED''',
    audit_column     => 'TRAINER_ID',
    statement_types  => 'UPDATE',
    enable           => TRUE
  );
END;